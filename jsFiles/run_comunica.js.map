{"version":3,"file":"run_comunica.js","sourceRoot":"","sources":["../run_comunica.ts"],"names":[],"mappings":"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","sourcesContent":["// import {LoggerTimer} from \"@comunica/logger-timer\";\r\n// import {QueryEngineFactory} from \"@comunica/query-sparql\";\r\nimport {MCTSJoinInformation} from '@comunica/model-trainer';\r\nimport { resolve } from 'path';\r\nimport {StaticPool} from 'node-worker-threads-pool';\r\n// const v8 = require('v8');\r\n// v8.setFlagsFromString('--stack-size=4096');\r\n\r\nconst fs = require('fs');\r\nconst http = require('http');\r\nconst path = require('path');\r\n\r\n\r\n\r\nconst options = {\r\n    hostname: 'localhost',\r\n    port: 3000,\r\n    path: '/sparql',\r\n    method: 'POST',\r\n    headers: {\r\n      'Accept': 'table',\r\n      'Content-Type': 'application/x-www-form-urlencoded',\r\n    }\r\n  };\r\n  \r\nclass trainComunicaModel{\r\n    public engine: any;\r\n    public queries: string[];\r\n    public loadedQueries: Promise<boolean>;\r\n    public modelTrainer;\r\n    public masterTree: any;\r\n    public runningMeanStd: number[][]\r\n\r\n    public constructor(){\r\n        const QueryEngine = require('@comunica/query-sparql-file').QueryEngineFactory;\r\n        this.modelTrainer = require('@comunica/model-trainer');\r\n        this.masterTree = new this.modelTrainer.MCTSMasterTree();\r\n        this.runningMeanStd = [[0, 0], [0, 0]]\r\n        this.engine = new QueryEngine().create({\r\n            configPath: __dirname+\"/config-file.json\", // Relative or absolute path \r\n        });\r\n        this.queries = [];\r\n    }\r\n\r\n    public async executeQuery(query: string, sources:string[], planHolder: Map<string, number>){\r\n        this.engine = await this.engine;\r\n        const bindingsStream = await this.engine.queryBindings(query, {sources: sources, masterTree: this.masterTree, planHolder: planHolder});\r\n        return bindingsStream\r\n    }\r\n\r\n    public async explainQuery(query:string, sources:string[]){\r\n        const results = await this.engine.explain(query, {sources: sources, masterTree: this.masterTree});\r\n        return results\r\n\r\n    }\r\n\r\n    public async trainModel(masterMap: Map<string, MCTSJoinInformation>, numEntries: number): Promise<number>{\r\n        // this.engine.getModelHolder().getModel().layersValue[0][0].mWeights.print() \r\n        this.engine = await this.engine;\r\n        const episodeLoss = this.engine.trainModel(masterMap, numEntries);\r\n        // this.engine.getModelHolder().getModel().denseLayerValue.getWeights()[0].print();\r\n        return episodeLoss\r\n    }\r\n\r\n    public async loadWatDivQueries(queryDir: string){\r\n        const fs = require('fs');\r\n        const path = require('path');\r\n        const loadingComplete = new Promise<boolean> (async (resolve, reject) => {\r\n            try {\r\n                // Get the files as an array\r\n                const files = await fs.promises.readdir( queryDir );\r\n                for( const file of files ) {\r\n                    // Get the full paths\r\n                    const filePath = path.join( queryDir, file );    \r\n                    const data = fs.readFileSync(filePath,'utf8');\r\n                    this.queries.push(data);\r\n                }\r\n                resolve(true); \r\n            }\r\n            catch( e ) {\r\n                console.error( \"Something went wrong.\", e );\r\n                reject();\r\n            }\r\n        });\r\n        return loadingComplete;\r\n    }\r\n\r\n    public resetMasterTree(){\r\n        this.masterTree = new this.modelTrainer.MCTSMasterTree();\r\n    }\r\n\r\n    public async awaitEngine(){\r\n        this.engine = await this.engine\r\n    }\r\n\r\n}\r\nconst nResults = [\r\n    0, 0,  0,  0, 4374, 4374,  0, 0,  1,\r\n    0, 0,  0,  0,    0,   33, 33, 3,  3,\r\n    1, 1, 60, 34,    0,    0,  2, 1, 13,\r\n    0, 0,  2,  0,    0,    0,  0, 0,  0,\r\n    0, 0,  2,  1\r\n  ]\r\n\r\n\r\nfunction stopCount(hrstart: [number, number]) {\r\n    // execution time simulated with setTimeout function\r\n    let hrend = process.hrtime(hrstart);\r\n    return hrend[0]*1000 + hrend[1]/1000000;\r\n}\r\n\r\nlet trainer: trainComunicaModel = new trainComunicaModel();\r\nconst loadingComplete: Promise<boolean> = trainer.loadWatDivQueries('output/queries');\r\nconst numSimulationsPerQuery: number = 20;\r\nconst numEpochs: number = 1000;\r\nconst hrTime = process.hrtime();\r\nlet numCompleted: number = 0;\r\n\r\n\r\nasync function executeQuery(beginTime: number, bindingStream: any, planMap: Map<string, number>, masterMap: Map<string, MCTSJoinInformation>){\r\n\r\n    let numEntriesPassed: number = 0;\r\n    let elapsed = 0;\r\n    const joinPlanQuery: string = Array.from(planMap)[planMap.size-1][0];\r\n    const finishedReading: Promise<boolean> = new Promise((resolve, reject) => {\r\n\r\n        bindingStream.on('data', (binding: any) => {\r\n            numEntriesPassed += 1\r\n            console.log(`${numEntriesPassed}`)\r\n        });\r\n\r\n        bindingStream.on('end', () => {\r\n            const end: number[] = process.hrtime();\r\n            const endSeconds: number = end[0] + end[1] / 1000000000;\r\n            elapsed = endSeconds-beginTime;\r\n\r\n            // Update the execution time for each joinPlan\r\n            planMap.forEach((value, key) => {const joinInformationPrev = masterMap.get(joinPlanQuery)! \r\n                joinInformationPrev.actualExecutionTime = elapsed;\r\n                masterMap.set(joinPlanQuery, joinInformationPrev);\r\n            })\r\n            console.log(`Elapsed time ${elapsed}`);\r\n            resolve(true);\r\n        });\r\n    })\r\n    await finishedReading\r\n    return elapsed\r\n}\r\n\r\nfunction addEndListener(beginTime: number, planMap: Map<string, number>, masterMap: Map<string, MCTSJoinInformation>, bindingStream: any, process: any): Promise<boolean>{\r\n    const joinPlanQuery: string = Array.from(planMap)[planMap.size-1][0];\r\n    let numEntriesPassed: number = 0;\r\n    const finishedReading: Promise<boolean> = new Promise((resolve, reject) => {\r\n        if (!masterMap.get(joinPlanQuery)!.actualExecutionTime || masterMap.get(joinPlanQuery)!.actualExecutionTime == 0){\r\n            bindingStream.on('data', (binding: any) => {\r\n                numEntriesPassed += 1\r\n                console.log(`${numEntriesPassed}`)\r\n            });\r\n            \r\n            bindingStream.on('end', () => {\r\n                const end: number[] = process.hrtime();\r\n                const endSeconds: number = end[0] + end[1] / 1000000000;\r\n                console.log(beginTime);\r\n                const elapsed: number = endSeconds-beginTime;\r\n                // planMap.forEach((value, key, map) => map.set(key, elapsed))\r\n                // Update the execution time for each joinPlan\r\n                planMap.forEach((value, key) => {\r\n                    const joinInformationPrev = masterMap.get(key.toString())! \r\n                    joinInformationPrev.actualExecutionTime = elapsed;\r\n                    masterMap.set(key.toString(), joinInformationPrev);\r\n                })\r\n                console.log(`Elapsed time ${elapsed}`);\r\n                // console.log(masterMap);\r\n\r\n                numCompleted += 1;\r\n                resolve(true);\r\n            })    \r\n    }});\r\n    return finishedReading;\r\n\r\n    // // Ensure we have our joinplan in the masterMap, this should always be true\r\n    // if (masterMap.get(joinPlanQuery)){\r\n    //     // We don't execute the query if we already recorded an execution time for this query during this epoch, this is to save time.\r\n    //     // console.log(masterMap.get(joinPlanQuery));\r\n    //     if (!masterMap.get(joinPlanQuery)!.actualExecutionTime || masterMap.get(joinPlanQuery)!.actualExecutionTime == 0){\r\n    //         bindingStream.on('data', (binding: any) => {\r\n    //             numEntriesPassed += 1\r\n    //             console.log(`${numEntriesPassed}`)\r\n    //         });\r\n            \r\n    //         bindingStream.on('end', () => {\r\n    //             console.log(\"End\")\r\n    //             const end: number[] = process.hrtime();\r\n    //             const endSeconds: number = end[0] + end[1] / 1000000000;\r\n    //             const elapsed: number = endSeconds-beginTime;\r\n    //             // planMap.forEach((value, key, map) => map.set(key, elapsed))\r\n    //             // Update the execution time for each joinPlan\r\n    //             planMap.forEach((value, key) => {const joinInformationPrev = masterMap.get(joinPlanQuery)! \r\n    //                 joinInformationPrev.actualExecutionTime = elapsed;\r\n    //                 masterMap.set(joinPlanQuery, joinInformationPrev);\r\n    //             })\r\n    //             console.log(`Elapsed time ${elapsed}`);\r\n    //             numCompleted += 1;\r\n    //             finishedReading.resolve()\r\n    //         })    \r\n    //     }\r\n    //     else{\r\n    //         numCompleted += 1;\r\n    //     }    \r\n    // }\r\n}\r\n\r\nloadingComplete.then( async result => {\r\n    let cleanedQueries: string[][] = trainer.queries.map(x => x.replace(/\\n/g, '').replace(/\\t/g, '').split('SELECT'));\r\n    // const resultQuery  = await trainer.executeQuery('SELECT * WHERE {?s ?p ?o } LIMIT 100', [\"output/dataset.nt\"]);\r\n    // const resultArray = [];\r\n\r\n    // // Perform one query to index the database into comunica \r\n    // const bindingsStream = await trainer.executeQuery('SELECT' + cleanedQueries[0][0], [\"output/dataset.nt\"]);\r\n\r\n    // HERE WE TEMPORARILY RESTRICT OUR QUERY TO TEST\r\n    await trainer.awaitEngine();\r\n    cleanedQueries = [cleanedQueries[7]]\r\n    const lossEpoch: number[] = []\r\n    for (let epoch = 0; epoch<numEpochs; epoch++){\r\n        const lossEpisode: number[] = []\r\n        for (let i = 0; i<cleanedQueries.length; i++){\r\n            // console.log(`cleanedQueries ${i+1}/${cleanedQueries.length}`);\r\n            const querySubset: string[] = [... cleanedQueries[i]];\r\n            querySubset.shift();\r\n            for (let j = 0; j <querySubset.length; j++){\r\n                // console.log(`Query ${'SELECT' + querySubset[j]}`);\r\n                /* Execute n queries and record the results */\r\n                const queryPromises: Promise<boolean>[] = [];\r\n                for (let n = 0; n < numSimulationsPerQuery; n++){\r\n                    let startTime = process.hrtime();\r\n                    const startTimeSeconds = startTime[0] + startTime[1] / 1000000000 ;\r\n                    const mapResults = new Map()\r\n                    const bindingsStream = await trainer.executeQuery('SELECT' + querySubset[j], [\"output/dataset.nt\"], mapResults);\r\n                    // queryPromises.push(addEndListener(startTimeSeconds, mapResults, trainer.masterTree.masterMap, bindingsStream, process));\r\n                    // const queryPromise = addEndListener(startTimeSeconds, mapResults, trainer.masterTree.masterMap, bindingsStream, process);\r\n                    // await queryPromise;\r\n                }\r\n                const numEntriesQuery: number = trainer.masterTree.getTotalEntries();\r\n                const tempMasterMap: Map<string, MCTSJoinInformation> = trainer.masterTree.masterMap;\r\n\r\n                // for (const value of tempMasterMap.values()){\r\n                //     console.log(value.featureMatrix);\r\n                // }\r\n                \r\n                // tempMasterMap.forEach( (value, key) => {console.log(value.featureMatrix)});\r\n                // Wait for all query executions to finish\r\n                // await Promise.all(queryPromises);\r\n\r\n                // const resultBindings = await bindingsStream.toArray();\r\n                // Wait for all queries in the episode to finish \r\n                // while (numCompleted < numSimulationsPerQuery){\r\n                //     continue;\r\n                // }\r\n                /* Train the model using the queries*/\r\n                let loss: number = await trainer.trainModel(trainer.masterTree.masterMap, numEntriesQuery);\r\n                trainer.resetMasterTree();\r\n                if (loss){\r\n                    lossEpisode.push(loss);\r\n                }\r\n                numCompleted = 0;\r\n                break;\r\n    \r\n                // resultArray.push(resultBindings.length);\r\n    \r\n                // await bindingsStream.on('data', (binding) => {\r\n                //     console.log(binding.toString()); // Quick way to print bindings for testing\r\n                // });             \r\n            }\r\n            break;\r\n        }\r\n        lossEpoch.push(sum(lossEpisode)/lossEpisode.length);\r\n        console.log(`Epoch ${epoch}, loss: ${lossEpoch[epoch]}`);\r\n    }\r\n    console.log(lossEpoch);\r\n    // console.log(resultArray);\r\n    // const stream = trainer.executeQuery('SELECT' + cleanedQueries[1], ['http://localhost:3000/sparql'])\r\n    function sum(arr: number[]) {\r\n        var result = 0, n = arr.length || 0; //may use >>> 0 to ensure length is Uint32\r\n        while(n--) {\r\n          result += +arr[n]; // unary operator to ensure ToNumber conversion\r\n        }\r\n        return result;\r\n      }\r\n      \r\n}\r\n\r\n)\r\n"]}