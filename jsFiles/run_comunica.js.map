{"version":3,"file":"run_comunica.js","sourceRoot":"","sources":["../run_comunica.ts"],"names":[],"mappings":"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","sourcesContent":["// import {LoggerTimer} from \"@comunica/logger-timer\";\r\n// import {QueryEngineFactory} from \"@comunica/query-sparql\";\r\nimport {MCTSJoinInformation, runningMoments, aggregateValues} from '@comunica/model-trainer';\r\nimport { resolve } from 'path';\r\nimport {StaticPool} from 'node-worker-threads-pool';\r\n// const v8 = require('v8');\r\n// v8.setFlagsFromString('--stack-size=4096');\r\n\r\nconst fs = require('fs');\r\nconst http = require('http');\r\nconst path = require('path');\r\n\r\n\r\n\r\nconst options = {\r\n    hostname: 'localhost',\r\n    port: 3000,\r\n    path: '/sparql',\r\n    method: 'POST',\r\n    headers: {\r\n      'Accept': 'table',\r\n      'Content-Type': 'application/x-www-form-urlencoded',\r\n    }\r\n  };\r\n  \r\nclass trainComunicaModel{\r\n    public engine: any;\r\n    public queries: string[];\r\n    public loadedQueries: Promise<boolean>;\r\n    public modelTrainer;\r\n    public masterTree: any;\r\n    public runningMoments: runningMoments;\r\n\r\n    public constructor(){\r\n        const QueryEngine = require('@comunica/query-sparql-file').QueryEngineFactory;\r\n        this.modelTrainer = require('@comunica/model-trainer');\r\n        this.runningMoments = {indexes: [0,7], runningStats: new Map<number, aggregateValues>()};\r\n        for (const index of this.runningMoments.indexes){\r\n            const startPoint: aggregateValues = {N: 0, mean: 0, std: 0, M2: 0}\r\n            this.runningMoments.runningStats.set(index, startPoint);\r\n        }\r\n\r\n        this.masterTree = new this.modelTrainer.MCTSMasterTree(this.runningMoments);\r\n        // Only standardise index 0: cardinality, index 7: number of variables in join\r\n        \r\n        this.engine = new QueryEngine().create({\r\n            configPath: __dirname+\"/config-file.json\", // Relative or absolute path \r\n        });\r\n        this.queries = [];\r\n    }\r\n\r\n    public async executeQuery(query: string, sources:string[], planHolder: Map<string, number>){\r\n        this.engine = await this.engine;\r\n        const bindingsStream = await this.engine.queryBindings(query, {sources: sources, masterTree: this.masterTree, planHolder: planHolder});\r\n        return bindingsStream\r\n    }\r\n\r\n    public async explainQuery(query:string, sources:string[]){\r\n        const results = await this.engine.explain(query, {sources: sources, masterTree: this.masterTree});\r\n        return results\r\n\r\n    }\r\n\r\n    public async trainModel(masterMap: Map<string, MCTSJoinInformation>, numEntries: number): Promise<number>{\r\n        // this.engine.getModelHolder().getModel().layersValue[0][0].mWeights.print() \r\n        this.engine = await this.engine;\r\n        const episodeLoss = this.engine.trainModel(masterMap, numEntries);\r\n        // this.engine.getModelHolder().getModel().denseLayerValue.getWeights()[0].print();\r\n        return episodeLoss\r\n    }\r\n\r\n    public async loadWatDivQueries(queryDir: string){\r\n        const fs = require('fs');\r\n        const path = require('path');\r\n        const loadingComplete = new Promise<boolean> (async (resolve, reject) => {\r\n            try {\r\n                // Get the files as an array\r\n                const files = await fs.promises.readdir( queryDir );\r\n                for( const file of files ) {\r\n                    // Get the full paths\r\n                    const filePath = path.join( queryDir, file );    \r\n                    const data = fs.readFileSync(filePath,'utf8');\r\n                    this.queries.push(data);\r\n                }\r\n                resolve(true); \r\n            }\r\n            catch( e ) {\r\n                console.error( \"Something went wrong.\", e );\r\n                reject();\r\n            }\r\n        });\r\n        return loadingComplete;\r\n    }\r\n\r\n    public resetMasterTree(){\r\n        this.masterTree = new this.modelTrainer.MCTSMasterTree(this.runningMoments);\r\n    }\r\n\r\n    public async awaitEngine(){\r\n        this.engine = await this.engine\r\n    }\r\n\r\n}\r\nconst nResults = [\r\n    0, 0,  0,  0, 4374, 4374,  0, 0,  1,\r\n    0, 0,  0,  0,    0,   33, 33, 3,  3,\r\n    1, 1, 60, 34,    0,    0,  2, 1, 13,\r\n    0, 0,  2,  0,    0,    0,  0, 0,  0,\r\n    0, 0,  2,  1\r\n  ]\r\n\r\n\r\nfunction stopCount(hrstart: [number, number]) {\r\n    // execution time simulated with setTimeout function\r\n    let hrend = process.hrtime(hrstart);\r\n    return hrend[0]*1000 + hrend[1]/1000000;\r\n}\r\n\r\nlet trainer: trainComunicaModel = new trainComunicaModel();\r\nconst loadingComplete: Promise<boolean> = trainer.loadWatDivQueries('output/queries');\r\n\r\n// Training parameters\r\nconst numSimulationsPerQuery: number = 8;\r\nconst numEpochs: number = 100;\r\nconst hrTime = process.hrtime();\r\n// Initialse moments, note that std = 1 to prevent division by 0\r\nconst runningMomentsY: aggregateValues = {N: 0, mean: 0, std: 1, M2: 0}\r\n\r\n\r\nloadingComplete.then( async result => {\r\n    let cleanedQueries: string[][] = trainer.queries.map(x => x.replace(/\\n/g, '').replace(/\\t/g, '').split('SELECT'));\r\n    // const resultQuery  = await trainer.executeQuery('SELECT * WHERE {?s ?p ?o } LIMIT 100', [\"output/dataset.nt\"]);\r\n    // const resultArray = [];\r\n\r\n    // // Perform one query to index the database into comunica \r\n    // const bindingsStream = await trainer.executeQuery('SELECT' + cleanedQueries[0][0], [\"output/dataset.nt\"]);\r\n\r\n    // HERE WE TEMPORARILY RESTRICT OUR QUERY TO TEST\r\n    await trainer.awaitEngine();\r\n    // cleanedQueries = cleanedQueries.slice(12,17)\r\n    cleanedQueries = cleanedQueries.slice(0,1);\r\n    const lossEpoch: number[] = []\r\n    for (let epoch = 0; epoch<numEpochs; epoch++){\r\n        const lossEpisode: number[] = []\r\n        for (let i = 0; i<cleanedQueries.length; i++){\r\n            // console.log(`cleanedQueries ${i+1}/${cleanedQueries.length}`);\r\n            const querySubset: string[] = [... cleanedQueries[i]];\r\n            console.log(querySubset);\r\n            querySubset.shift();\r\n            for (let j = 0; j <querySubset.length; j++){\r\n                /* Execute n queries and record the results */\r\n                for (let n = 0; n < numSimulationsPerQuery; n++){\r\n\r\n                    let startTime = process.hrtime();\r\n                    const startTimeSeconds = startTime[0] + startTime[1] / 1000000000 ;\r\n                    const mapResults = new Map()\r\n                    const bindingsStream = await trainer.executeQuery('SELECT' + querySubset[j], [\"outputSampled/dataset.nt\"], mapResults);\r\n                    // queryPromises.push(addEndListener(startTimeSeconds, mapResults, trainer.masterTree.masterMap, bindingsStream, process));\r\n                    const queryPromise = addEndListener(startTimeSeconds, mapResults, trainer.masterTree.masterMap, bindingsStream, process, runningMomentsY);\r\n                    await queryPromise;\r\n                }\r\n                const numEntriesQuery: number = trainer.masterTree.getTotalEntries();\r\n                console.log(trainer.masterTree.masterMap);\r\n                // Normalize the y values\r\n\r\n\r\n                for (const key of trainer.masterTree.masterMap.keys()){\r\n                    const joinToNormalize: MCTSJoinInformation = trainer.masterTree.masterMap.get(key.toString());\r\n                    joinToNormalize.actualExecutionTime = (joinToNormalize.actualExecutionTime! - runningMomentsY.mean)/runningMomentsY.std;\r\n                }\r\n\r\n                /* Train the model using the queries*/\r\n                let loss: number = await trainer.trainModel(trainer.masterTree.masterMap, numEntriesQuery);\r\n                trainer.resetMasterTree();\r\n                if (loss){\r\n                    lossEpisode.push(loss);\r\n                }\r\n            }\r\n        }\r\n        lossEpoch.push(sum(lossEpisode)/lossEpisode.length);\r\n        console.log(`Epoch ${epoch}, loss: ${lossEpoch[epoch]}`);\r\n    }\r\n    console.log(lossEpoch);\r\n    // console.log(resultArray);\r\n    // const stream = trainer.executeQuery('SELECT' + cleanedQueries[1], ['http://localhost:3000/sparql'])\r\n});\r\n\r\nfunction sum(arr: number[]) {\r\n    var result = 0, n = arr.length || 0; //may use >>> 0 to ensure length is Uint32\r\n    while(n--) {\r\n      result += +arr[n]; // unary operator to ensure ToNumber conversion\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction addEndListener(beginTime: number, planMap: Map<string, number>, masterMap: Map<string, MCTSJoinInformation>, \r\n    bindingStream: any, process: any, runningMomentsY: aggregateValues): Promise<boolean>{\r\n    /**\r\n     * Function that consumes the binding stream and measures elapsed time\r\n     */\r\n    const joinPlanQuery: string = Array.from(planMap)[planMap.size-1][0];\r\n    let numEntriesPassed: number = 0;\r\n    const finishedReading: Promise<boolean> = new Promise((resolve, reject) => {\r\n        if (!masterMap.get(joinPlanQuery)!.actualExecutionTime || masterMap.get(joinPlanQuery)!.actualExecutionTime == 0){\r\n            bindingStream.on('data', (binding: any) => {\r\n                numEntriesPassed += 1\r\n                // console.log(`Entry Number:${numEntriesPassed}`)\r\n            });\r\n            \r\n            bindingStream.on('end', () => {\r\n                const end: number[] = process.hrtime();\r\n                const endSeconds: number = end[0] + end[1] / 1000000000;\r\n                const elapsed: number = endSeconds-beginTime;\r\n                // Update the running moments\r\n                updateRunningMoments(runningMomentsY, elapsed);\r\n                // Update the standardized execution time for each joinPlan\r\n                planMap.forEach((value, key) => {\r\n                    const joinInformationPrev = masterMap.get(key.toString())! \r\n                    joinInformationPrev.actualExecutionTime = elapsed;\r\n                    masterMap.set(key.toString(), joinInformationPrev);\r\n                })\r\n                // console.log(`Elapsed time ${elapsed}`);\r\n                // console.log(masterMap);\r\n                resolve(true);\r\n            })    \r\n    }});\r\n    return finishedReading;\r\n}\r\n\r\nasync function executeQuery(beginTime: number, bindingStream: any, planMap: Map<string, number>, masterMap: Map<string, MCTSJoinInformation>){\r\n\r\n    let numEntriesPassed: number = 0;\r\n    let elapsed = 0;\r\n    const joinPlanQuery: string = Array.from(planMap)[planMap.size-1][0];\r\n    const finishedReading: Promise<boolean> = new Promise((resolve, reject) => {\r\n\r\n        bindingStream.on('data', (binding: any) => {\r\n            numEntriesPassed += 1\r\n            // console.log(`${numEntriesPassed}`)\r\n        });\r\n\r\n        bindingStream.on('end', () => {\r\n            const end: number[] = process.hrtime();\r\n            const endSeconds: number = end[0] + end[1] / 1000000000;\r\n            elapsed = endSeconds-beginTime;\r\n\r\n            // Update the execution time for each joinPlan\r\n            planMap.forEach((value, key) => {const joinInformationPrev = masterMap.get(joinPlanQuery)! \r\n                joinInformationPrev.actualExecutionTime = elapsed;\r\n                masterMap.set(joinPlanQuery, joinInformationPrev);\r\n            })\r\n            // console.log(`Elapsed time ${elapsed}`);\r\n            resolve(true);\r\n        });\r\n    })\r\n    await finishedReading\r\n    return elapsed\r\n}\r\nfunction updateRunningMoments(toUpdateAggregate: aggregateValues, newValue: number){\r\n    toUpdateAggregate.N +=1;\r\n    const delta = newValue - toUpdateAggregate.mean; \r\n    toUpdateAggregate.mean += delta / toUpdateAggregate.N;\r\n    const newDelta = newValue - toUpdateAggregate.mean;\r\n    toUpdateAggregate.M2 += delta * newDelta;\r\n    toUpdateAggregate.std = Math.sqrt(toUpdateAggregate.M2 / toUpdateAggregate.N);\r\n}"]}